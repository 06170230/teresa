# Leetcode
## 101. Symmetric Tree
判斷右邊是不是左邊的鏡像，就是先把右邊的樹反轉，再判斷是否與左邊的樹相等。 剛好怎麼把樹反轉在Invert Binary Tree有寫過，Same Tree也寫過，把這兩個組合起來就是本題的解了。

## 136. Single Number
我能想到的最直接的思路就是先排序然後從頭到尾比較後找出那個唯一的數字，但是這種思路很簡單粗暴，感覺一定不是出題人想要的答案，而且並不太能滿足注意事項，但想不出別的我只能先這樣實現了，然後我看了看別人的高級做法頓時覺得思路清奇實在是精妙無比。

先說排序的做法，直接使用Java的排序函數對數組進行排序，然後從頭到尾進行比較，注意要考慮只有一個數字的極端情況，以及單個數字在數組頭或者數組尾的情況，還有就是在比較時你會發現，數組排序後，這個數字絕對不可能出現在第二位或者倒數第二位，因為這樣的話第一位或者最後一位數字就尷尬了。

## 38. Count and Say
1     讀做 1個1， 所以下一個變成 11  
11    讀做 2個1， 也就是21  
21    讀做 1個2 1個1，得到1211
1211  1個1，1個2，2個1  111221  

## 115. Distinct Subsequences 
這個題一看就是DP。向字符串序列問題確實有很多都是用DP求解的。

設dp數組dp[i][j]表示S的前j個字符是T的前i個字符的子序列的個數為dp[i][j]。

那麼有dp[0][*] == 1，因為這個情況下，只能使用s的空字符串進行匹配t。

如果s[j - 1] == t[i - 1]，那麼，dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]，原因是t的前j個字符可以由s的前[i - 1]個字符和t的前[j - 1]個匹配的同時最後一個字符匹配，加上s的前[j - 1]個字符和t的前[i]個字符匹配同時丟棄s的第[j]個字符。

如果s[j - 1] != t[i - 1]，那麼dp[i][j] = dp[i][j - 1]，因為只能是前面的匹配，最後一個字符不能匹配，所以丟棄了。
## 207. Course Schedule
看到給的第二個測試用例立馬就明白了，就是判斷這些課程能否構成有向無環圖（DAG）。而任何時候判斷DAG的方法要立刻想到拓撲排序。

拓撲排序是對有向無環圖（DAG）而言的，對圖進行拓撲排序即求其中節點的一個拓撲序列，對於所有的有向邊（U, V）（由U指向V），在該序列中節點U都排在節點V之前。

方法是每次選擇入度為0的節點，作為序列的下一個節點，然後移除該節點和以從節點出發的所有邊。

那這個方法比較簡單粗暴了：要循環N次，這個循環次數並不是遍歷節點的意思，而是我們如果正常取點的話，N次就能把所有的節點都取完了，如果N次操作結束還沒判斷出來，那麼就不是DAG.在這N次中，每次都找一個入度為0的點，並把它的入度變為-1，作為已經取過的點不再使用，同時把從這個點指向的點的入度都-1.

這個過程中，如果找不到入度為0的點，那麼說明存在環。如果N次操作，每次都操作成功的去除了一個入度為0的點，那麼說明這個圖是DAG.

時間複雜度是O(N ^ 2)，空間複雜度是O(N)。


